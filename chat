import azure.functions as functions
from helpers.transaction_handler import (
    validate_transaction,
    process_transaction,
    record_balance_history
)

# Create a new blueprint for the transaction processing
transactions_blueprint = functions.Blueprint()

@transactions_blueprint.function_name("process_transaction")
@transactions_blueprint.route(route="transactions", methods=["POST"], auth_level="function")
async def process_transaction(req: functions.HttpRequest) -> functions.HttpResponse:
    """Main function to handle POST transactions"""
    
    try:
        # Step 1: Parse the request body
        transaction_data = req.get_json()

        # Step 2: Validate the transaction data (check if trace number exists, accounts exist, and sufficient funds)
        validation_response = await validate_transaction(transaction_data)
        if validation_response["status"] != 200:
            return functions.HttpResponse(
                validation_response["message"], status_code=validation_response["status"]
            )

        # Step 3: Process the transaction (update account balances)
        await process_transaction(transaction_data)

        # Step 4: Record the balance history for both debit and credit accounts
        await record_balance_history(transaction_data)

        # Step 5: Return success (201)
        return functions.HttpResponse(
            "Transaction processed successfully", status_code=201
        )

    except Exception as e:
        logging.error(f"Error processing transaction: {str(e)}")
        return functions.HttpResponse(
            "Transaction failed due to an internal error", status_code=500
        )


from sqlalchemy.orm import sessionmaker
from models import Transaction, Account, AccountBalanceHistory
from datetime import datetime
import logging

Session = sessionmaker(bind=engine)  # Database engine configuration should be here

async def validate_transaction(transaction_data):
    session = Session()

    try:
        trace_number = transaction_data['trace_number']
        debit_account_number = transaction_data['debit_account_number']
        credit_account_number = transaction_data['credit_account_number']
        transaction_amount = transaction_data['transaction_amount']

        # Check if the trace number already exists
        existing_transaction = session.query(Transaction).filter_by(trace_number=trace_number).first()
        if existing_transaction:
            return {"message": "Transaction already exists", "status": 202}

        # Check if accounts exist
        debit_account = session.query(Account).filter_by(account_number=debit_account_number).first()
        credit_account = session.query(Account).filter_by(account_number=credit_account_number).first()

        if not debit_account or not credit_account:
            return {"message": "One or both accounts not found", "status": 404}

        # Check if the debit account has sufficient funds
        if debit_account.available_balance < transaction_amount:
            return {"message": "Insufficient funds in debit account", "status": 400}

        return {"message": "Validation successful", "status": 200}
    
    except Exception as e:
        logging.error(f"Error validating transaction: {str(e)}")
        return {"message": "Internal validation error", "status": 500}
    
    finally:
        session.close()


async def process_transaction(transaction_data):
    session = Session()

    try:
        debit_account_number = transaction_data['debit_account_number']
        credit_account_number = transaction_data['credit_account_number']
        transaction_amount = transaction_data['transaction_amount']

        # Fetch debit and credit accounts
        debit_account = session.query(Account).filter_by(account_number=debit_account_number).first()
        credit_account = session.query(Account).filter_by(account_number=credit_account_number).first()

        # Update balances
        debit_account.available_balance -= transaction_amount
        credit_account.available_balance += transaction_amount

        # Create a new transaction entry
        new_transaction = Transaction(
            trace_number=transaction_data['trace_number'],
            debit_account_number=debit_account_number,
            credit_account_number=credit_account_number,
            transaction_amount=transaction_amount,
            withdrawal_description=transaction_data.get('withdrawal_description', ''),
            deposit_description=transaction_data.get('deposit_description', ''),
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )

        session.add(new_transaction)
        session.commit()

    except Exception as e:
        logging.error(f"Error processing transaction: {str(e)}")
        session.rollback()

    finally:
        session.close()


async def record_balance_history(transaction_data):
    session = Session()

    try:
        debit_account_number = transaction_data['debit_account_number']
        credit_account_number = transaction_data['credit_account_number']
        transaction_amount = transaction_data['transaction_amount']

        debit_account = session.query(Account).filter_by(account_number=debit_account_number).first()
        credit_account = session.query(Account).filter_by(account_number=credit_account_number).first()

        # Record balance history for debit and credit accounts
        debit_history = AccountBalanceHistory(
            account_number=debit_account_number,
            balance_before=debit_account.available_balance + transaction_amount,
            balance_after=debit_account.available_balance
        )
        credit_history = AccountBalanceHistory(
            account_number=credit_account_number,
            balance_before=credit_account.available_balance - transaction_amount,
            balance_after=credit_account.available_balance
        )

        session.add(debit_history)
        session.add(credit_history)
        session.commit()

    except Exception as e:
        logging.error(f"Error recording balance history: {str(e)}")
        session.rollback()

    finally:
        session.close()
