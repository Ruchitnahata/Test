import azure.functions as func
import logging
import json
from datetime import datetime
from sqlalchemy import create_engine, Column, String, Boolean, DateTime, Numeric
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

Base = declarative_base()

# SQLAlchemy models
class Transaction(Base):
    __tablename__ = 'transactions'
    trace_number = Column(String, primary_key=True)
    debit_account_number = Column(String)
    credit_account_number = Column(String)
    transaction_amount = Column(Numeric)
    withdrawal_description = Column(String)
    deposit_description = Column(String)
    withdrawal_transaction_type_code = Column(String)
    deposit_transaction_type_code = Column(String)
    clearing_category_code = Column(String)
    fund_type_code = Column(String)
    fund_type_detail_code = Column(String)
    transaction_type = Column(String)
    sent_to_vendor = Column(Boolean, default=None)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


class Account(Base):
    __tablename__ = 'accounts'
    account_number = Column(String, primary_key=True)
    customer_id = Column(String)
    date_opened = Column(DateTime)
    account_holder_name = Column(String)
    major_account_type = Column(String)
    minor_account_type = Column(String)
    account_status = Column(String)
    available_balance = Column(Numeric)
    current_balance = Column(Numeric)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


class AccountBalanceHistory(Base):
    __tablename__ = 'account_balance_history'
    id = Column(String, primary_key=True)
    account_number = Column(String)
    balance_before = Column(Numeric)
    balance_after = Column(Numeric)
    created_at = Column(DateTime, default=datetime.utcnow)


# Database connection
engine = create_engine('your_database_connection_string')
Session = sessionmaker(bind=engine)

def main(req: func.HttpRequest) -> func.HttpResponse:
    logging.info('Processing transaction request')
    session = Session()

    try:
        # Step 1: Parse the request
        transaction_data = req.get_json()

        trace_number = transaction_data['trace_number']
        debit_account_number = transaction_data['debit_account_number']
        credit_account_number = transaction_data['credit_account_number']
        transaction_amount = transaction_data['transaction_amount']

        # Step 2: Check if the trace number already exists
        existing_transaction = session.query(Transaction).filter_by(trace_number=trace_number).first()
        if existing_transaction:
            return func.HttpResponse(json.dumps({"message": "Transaction already exists", "status": 202}),
                                     status_code=202)

        # Step 3: Validate that accounts exist
        debit_account = session.query(Account).filter_by(account_number=debit_account_number).first()
        credit_account = session.query(Account).filter_by(account_number=credit_account_number).first()

        if not debit_account or not credit_account:
            return func.HttpResponse(json.dumps({"message": "One or both accounts not found", "status": 404}),
                                     status_code=404)

        # Step 4: Check if the debit account has sufficient funds
        if debit_account.available_balance < transaction_amount:
            return func.HttpResponse(json.dumps({"message": "Insufficient funds in debit account", "status": 400}),
                                     status_code=400)

        # Step 5: Record balance history for debit and credit accounts
        debit_history = AccountBalanceHistory(
            account_number=debit_account_number,
            balance_before=debit_account.available_balance,
            balance_after=debit_account.available_balance - transaction_amount
        )
        credit_history = AccountBalanceHistory(
            account_number=credit_account_number,
            balance_before=credit_account.available_balance,
            balance_after=credit_account.available_balance + transaction_amount
        )

        session.add(debit_history)
        session.add(credit_history)

        # Step 6: Update balances
        debit_account.available_balance -= transaction_amount
        credit_account.available_balance += transaction_amount

        # Step 7: Create the transaction
        new_transaction = Transaction(
            trace_number=trace_number,
            debit_account_number=debit_account_number,
            credit_account_number=credit_account_number,
            transaction_amount=transaction_amount,
            withdrawal_description=transaction_data.get('withdrawal_description', ''),
            deposit_description=transaction_data.get('deposit_description', ''),
            withdrawal_transaction_type_code=transaction_data.get('withdrawal_transaction_type_code', ''),
            deposit_transaction_type_code=transaction_data.get('deposit_transaction_type_code', ''),
            clearing_category_code=transaction_data.get('clearing_category_code', ''),
            fund_type_code=transaction_data.get('fund_type_code', ''),
            fund_type_detail_code=transaction_data.get('fund_type_detail_code', ''),
            transaction_type=transaction_data.get('transaction_type', ''),
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )

        session.add(new_transaction)
        session.commit()

        # Step 8: Return success
        return func.HttpResponse(json.dumps({"message": "Transaction processed", "status": 201}),
                                 status_code=201)

    except Exception as e:
        logging.error(f"Error processing transaction: {str(e)}")
        session.rollback()
        return func.HttpResponse(json.dumps({"message": "Transaction failed", "status": 500}),
                                 status_code=500)
    finally:
        session.close()
